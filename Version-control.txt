
Using External Library for Email/SMS/Push Notifications:
This approach involves using an external library to send alerts through email, SMS, or push notifications. Libraries like twilio for SMS or cloud platforms like Amazon SNS can be used. Here's a basic example using twilio (replace placeholders with your account details):

Python
from twilio.rest import Client

# Replace with your Twilio account details
account_sid = "YOUR_ACCOUNT_SID"
auth_token = "YOUR_AUTH_TOKEN"
client = Client(account_sid, auth_token)

def send_alert(message):
  """Sends an SMS alert using Twilio."""
  client.messages.create(
      to="YOUR_PHONE_NUMBER",
      from_="YOUR_TWILIO_NUMBER",
      body=message
  )

# ... rest of your code ...

if len(faces) + len(bodies) > 0:
    # ... existing logic
    send_alert("Intruder detected in video stream!")


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	You're all verified!
If you lose your phone, or don’t have access to your verification device, this code is your failsafe to access your account.

Recovery code
BW2EZQDU7KH2C2QHKKFV7LLV

(warning)
Save this code somewhere safe and accessible

Continue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


**************************************************twilio guidelines********************
Instructions:
Install the Twilio library if you haven't already:

bash
Copy code
pip install twilio
Replace the placeholders with your actual Twilio account SID, auth token, your phone number, and your Twilio number.

Run the script. The script will start capturing video from your webcam, detect faces and bodies, and send an SMS alert using Twilio if any are detected.

Notes:
Ensure that you have a Twilio account set up and that your phone number is verified with Twilio.
Make sure the haarcascade XML files are correctly located in your OpenCV installation.
Check your Twilio balance and SMS sending limits to avoid unexpected charges.


***************************************************************Baked version 1**********************************************
To integrate the face detection and recognition code with the RFID functionality, we will follow these steps:

Use the RFID reading logic to get the RFID card ID.
Use the face recognition code to recognize the face in the video stream.
Compare the RFID card ID with the recognized face.
Generate an alert if the face does not match the RFID card.
Here’s the final code combining both functionalities:

python
Copy code
import os
import cv2
import face_recognition
import numpy as np
import time
import datetime
from twilio.rest import Client

# Replace with your Twilio account details
account_sid = "YOUR_ACCOUNT_SID"
auth_token = "YOUR_AUTH_TOKEN"
client = Client(account_sid, auth_token)

def send_alert(message):
    """Sends an SMS alert using Twilio."""
    client.messages.create(
        to="YOUR_PHONE_NUMBER",
        from_="YOUR_TWILIO_NUMBER",
        body=message
    )

def get_encoded_faces():
    """Encodes all faces in the faces directory."""
    encoded = {}
    for dirpath, dnames, fnames in os.walk("./faces"):
        for f in fnames:
            if f.endswith(".jpg") or f.endswith(".png"):
                face = face_recognition.load_image_file(os.path.join(dirpath, f))
                encoding = face_recognition.face_encodings(face)[0]
                encoded[f.split(".")[0]] = encoding
    return encoded

def unknown_image_encoded(img):
    """Encodes a face given the image file."""
    face = face_recognition.load_image_file(img)
    encoding = face_recognition.face_encodings(face)[0]
    return encoding

def classify_face(frame, faces, faces_encoded, known_face_names):
    """Classifies the face in the frame and returns the face names."""
    face_locations = face_recognition.face_locations(frame)
    unknown_face_encodings = face_recognition.face_encodings(frame, face_locations)

    face_names = []
    for face_encoding in unknown_face_encodings:
        matches = face_recognition.compare_faces(faces_encoded, face_encoding)
        name = "Unknown"
        face_distances = face_recognition.face_distance(faces_encoded, face_encoding)
        best_match_index = np.argmin(face_distances)
        if matches[best_match_index]:
            name = known_face_names[best_match_index]
        face_names.append(name)

        for (top, right, bottom, left), name in zip(face_locations, face_names):
            cv2.rectangle(frame, (left - 20, top - 20), (right + 20, bottom + 20), (255, 0, 0), 2)
            cv2.rectangle(frame, (left - 20, bottom - 15), (right + 20, bottom + 20), (255, 0, 0), cv2.FILLED)
            font = cv2.FONT_HERSHEY_DUPLEX
            cv2.putText(frame, name, (left - 20, bottom + 15), font, 1.0, (255, 255, 255), 2)
    return face_names

# Placeholder for RFID reading function
def read_rfid_sensor():
    """Reads RFID card and returns card ID."""
    # Replace with your actual RFID reading logic
    return "sample_rfid_id"  # Example RFID ID

# Example database linking RFID card IDs to face IDs
authorized_faces = {
    "authorized_rfid_id_1": "authorized_face_id_1",
    "authorized_rfid_id_2": "authorized_face_id_2"
}

cap = cv2.VideoCapture(0)

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")
body_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_fullbody.xml")

detection = False
detection_stopped_time = None
timer_started = False
SECONDS_TO_RECORD_AFTER_DETECTION = 5

frame_size = (int(cap.get(3)), int(cap.get(4)))
fourcc = cv2.VideoWriter_fourcc(*"mp4v")

faces = get_encoded_faces()
faces_encoded = list(faces.values())
known_face_names = list(faces.keys())

while True:
    _, frame = cap.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces_detected = face_cascade.detectMultiScale(gray, 1.3, 5)
    bodies = body_cascade.detectMultiScale(gray, 1.3, 5)

    rfid_detected = read_rfid_sensor()
    face_detected = len(faces_detected) > 0

    if rfid_detected and face_detected:
        face_names = classify_face(frame, faces, faces_encoded, known_face_names)
        if authorized_faces.get(rfid_detected) not in face_names:
            print("RFID and face do not match. Alerting!")
            send_alert("Intruder detected: RFID and face do not match!")
        else:
            print("Authorized access.")

    if len(faces_detected) + len(bodies) > 0:
        if detection:
            timer_started = False
        else:
            detection = True
            current_time = datetime.datetime.now().strftime("%d-%m-%Y-%H-%M-%S")
            out = cv2.VideoWriter(f"{current_time}.mp4", fourcc, 20, frame_size)
            print("Started Recording!")
    elif detection:
        if timer_started:
            if time.time() - detection_stopped_time >= SECONDS_TO_RECORD_AFTER_DETECTION:
                detection = False
                timer_started = False
                out.release()
                print('Stop Recording!')
        else:
            timer_started = True
            detection_stopped_time = time.time()

    if detection:
        out.write(frame)

    cv2.imshow("Camera", frame)

    if cv2.waitKey(1) == ord('q'):
        break

if 'out' in locals():
    out.release()
cap.release()
cv2.destroyAllWindows()
Explanation:
Face Encoding and Recognition:

The get_encoded_faces() function encodes all faces in the faces directory.
The classify_face() function recognizes faces in a given frame and labels them.
RFID Reading:

The read_rfid_sensor() function is a placeholder for RFID reading logic.
Authorization Check:

The authorized_faces dictionary links RFID card IDs to face IDs.
When both an RFID card and a face are detected, the code compares them. If they do not match, an alert is sent.
Video Recording:

The video recording logic is integrated with the detection logic.
Note:
Ensure you have the necessary hardware and libraries installed for RFID and face recognition.
Test individual components (RFID reading, face recognition) separately before integrating them.
Update the Twilio account details and authorized faces database as needed.